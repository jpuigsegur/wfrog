#summary Ideas that will guide the development of wrfog 0.5.

= Architecture Details =

It is structured in 4 components:


1) driver

- reads / retrieves / receives / etc. data from the weather station and sends part of it (external temperature & humidity, wind, station pressure and rain) to the logger via messages. Optionally the driver can produce an xml file with the current conditions as would be seen on the station console.

2) logger

- Receives the data from the driver and every n minutes writes a new record to the database.

_Comment by Laurent_

I think that there are actually three steps in collecting the data:

i) The driver collects "raw" data at a rate decided by the station and not the same for all sensors. Then it sends this data to

ii) An aggregator which accumulate the data until a "sample" should be issued. A sample is actually the content of a db row. Accumulating means calculating the min max. The time between two samples is precisely the configurable value which is typically 15 min. The accumulator also maintains the current-condition xml file. When the aggregator "issues" samples, it sends them to

iii) The actual logger which simply does inserts in the table.

In my opinion, these three components should have each one its own thread. They communicate though a Queue (in blocking manner). Then, in a further step, we can even imagine running them in different processes, so that they can be deployed remotely, for example. It makes also sense to have a decoupling in the case the driver is developed in another technology. In this latter case, decoupling the driver and aggregator makes the work of writing a new driver very simple.

_End of Comment_


3) database

- Use real multiuser DBMS, allowing data query from other computers, online backups, etc.

- Keep SQL sentences standard so that most DBMS can be used. So far we have tested Firebird 2.1

- Keep the database simple: 1 table with one record every n minutes (by default 15) plus 1 index. This gives around 35000 rows per year which allow most reasonable queries to run directly on that table.

- The database units should be metric.

4) renderer & uploader

- Produces any file (html / xml / txt / graphs / etc.) requested by the user containing current data, daily/monthly/yearly aggregates, etc. etc. The renderer obtains the data by accessing to the database, and uploads those files to the requested destinations.

Ideally 1,2 and 4 should be separate OS processes (3 will always be), with separate configs, etc. (this implies using some os mechanism like named pipes, etc. to communicate, which is not that difficult).

= Interprocess communication =

In order to be able to have different process for the logger, driver and renderer we need means of communication between them. The goal is to have the most generic type of communication possible in order to allow processes to run on different machines, different platforms (windows and linux for instance), etc. Here is a proposal that should allow this:

1 ) logger -> renderer

The renderer process extracts all information directly from the database. In order to detect the arrival of new data it can easily query the database every min or 30 sec. with the following select:

SELECT MAX(TIMESTAMP_UTC) FROM METEO.

Since there is an ascending index such query is fast and light and therefore there's no need to have other means of communication.


2) driver -> logger

Use XMLRPC calls. XMLRPC is a simple RPC protocol without the compatibility issues of SOAP and very easy to implement in Python. Python has the following two modules:

- SimpleXMLRPCServer  (xmlrpc.server in Python 3.0)
- xmlrpcclib  (xmlrpc.client in Python 3.0)

Eventually it would also be possible to write drivers in another language implementing this protocol.

The idea would be to implement the following calls:

report_rain(total, rate)
report_wind(dirDeg, avgSpeed, gustSpeed)
report_barometer(pressure)
report_temperature(temp, humidity)
report_uv(uv)

_Comment by Laurent_

I've read your ideas about xmlrpc. I think it is a good idea to provide a XML over HTTP communication channel. However, if we base the internal architecture on Queues and want to describe univoqually the XML interface with a XSD schema, we should maybe prefer a more message-oriented integration. Like simply accept the driver events as schema-defined XML messages POSTed on a SimpleHTTPServer. This way, we could use the same XML messages also if some integration is done through another transport (pipes, files, ...).

In my idea, it would be possible to launch the driver and logger with such commands:
{{{
wfdriver --station=wmrs200 --device=/dev/usbTTy0 --output=stdout | wflogger --input=stdin
}}}
Or if we have them on a different machine:
{{{
wfdriver --station=wmrs200 --device=/dev/usbTTy0 --output=http --url=http://loggerhost:7878/wflogger

wflogger --input=http --port=7878
}}}

See below the message-oriented alternative.

_End of Comment_

==Message-Oriented Alternative==

In a more message-oriented way, the idea is to pass events instead of performing calls. A typical event would be:

{{{
event.type = 'temp'
event.sensor = 0
event.value = 15
}}}

With a corresponding XML representation:
{{{
<temp>
  <sensor>0</sensor>
  <value>15</value>
</temp>
}}}

Setting up connectors able to listen evens from stdin or http requires a bit of low-level infrastructure illustrated in: http://code.google.com/p/wfrog/source/browse/trunk/wfrender/test/xmlstream.py

This example file is working and shows boths of these connectors. The XML binding requires lxml:
{{{
$ easy_install lxml
}}}

To test the stdin connector:
{{{
$ cat stream.xml | python xmlstream.py
}}}

To test the http one:
{{{
python xmlstream.py -s http
}}}
and in another shell:
{{{
wget -t 1 --post-data "<temp><sensor>0</sensor><value>4</value></temp>" http://localhost:8080
}}}

The example also shows internal decoupling with a blocking queue and local creation of events in the case where the driver would be embedded in the sames python process as the logger.

= Data model =

{{{
CREATE TABLE METEO(
  TIMESTAMP_UTC Timestamp NOT NULL,
  TIMESTAMP_LOCAL Timestamp NOT NULL,
  TEMP Numeric(3,1),
  TEMP_MIN Numeric(3,1),
  TEMP_MIN_TIME Timestamp,
  TEMP_MAX Numeric(3,1),
  TEMP_MAX_TIME Timestamp,
  HUM Numeric(2,1),
  WIND Numeric(4,1),
  WIND_DIR Smallint,
  WIND_GUST Numeric(4,1),
  WIND_GUST_DIR Smallint,
  WIND_GUST_TIME Timestamp,
  DEW_POINT Numeric(3,1),
  RAIN Numeric(5,1),
  RAIN_RATE Numeric(5,1),
  RAIN_RATE_TIME Timestamp,
  PRESSURE Numeric(5,1),
  CONSTRAINT PK_METEO PRIMARY KEY (TIMESTAMP_UTC)
);

CREATE DESCENDING INDEX IDX_METEO1 ON METEO (TIMESTAMP_LOCAL);
}}}

= Project Structure =

Proposal for the project structure. Taken from http://jcalderone.livejournal.com/39794.html and state-of-the-art on other projects.

{{{
trunk/           (will be copied to tags/wfrog-0.1 and targzipped for release)
   bin/          (bootstrap executable files)
     wfdriver
     wflogger
     wfrender
   wfdriver/
     -base python files-
     stations/
        wmrs200.py
        wmr98nx.py
     config/
        -default and sample configuration files-
   wflogger/
     -python files-
     db/
       db.sql  
     config/
        -default and sample configuration files-
   wfrender/
     -python files-
     data/
        -python files-
     renderer/
        -python files-
     templates/
        -builtin templates-
     config/
        -default and sample configuration files-
  README
  setup.py
}}}